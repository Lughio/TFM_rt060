clc;
clear;
close all;

% ========================================================================
%  UNIDAD DIDÁCTICA: RESPUESTA AL ESCALÓN Y ESTIMACIÓN AUTOMÁTICA DE PARÁMETROS
%  Este script realiza un experimento real en la maqueta RT060 para:
%   1. Aplicar una entrada escalón de voltaje y capturar la respuesta de posición.
%   2. Estimar automáticamente los parámetros de la planta (ganancia, tiempo muerto y
%      constante de tiempo) a partir de los datos experimentales.
% ========================================================================

%% PASO 1: PARÁMETROS DE CONFIGURACIÓN DEL EXPERIMENTO Y DEL HARDWARE

% --- PARÁMETROS DEL EXPERIMENTO ---
voltaje_escalon = 2.0;       % VOLTAJE DEL ESCALÓN A APLICAR [V]. ¡CUIDADO DE NO USAR UNO MUY ALTO!
tiempo_experimento = 20;     % DURACIÓN DEL REGISTRO DE DATOS [S]
dt = 0.05;                   % PERÍODO DE MUESTREO PARA LA CAPTURA DE DATOS [S]

% --- PARÁMETROS DE CALIBRACIÓN Y CONEXIÓN DE LA MAQUETA RT060 ---
idnum = -1;
demo = 0;
canal = 0;
gain_conversion = 7.36;      % GANANCIA DE CONVERSIÓN [CM/V]
offset_conversion = 0.22;    % OFFSET DE CONVERSIÓN [CM]
gain_direction = 0.2;
bias_direction = 1;
bias_motor = 0.9;
pos_max_cm = 30.0;

%% PASO 2: EJECUCIÓN DEL EXPERIMENTO EN LAZO ABIERTO
try
    % --- INICIALIZACIÓN: MOVER EL CARRO A LA POSICIÓN INICIAL (0 CM) ---
    disp('--- INICIALIZANDO EXPERIMENTO ---');
    disp('MOVIENDO EL CARRO A LA POSICIÓN INICIAL...');
    mover_posicion(0, idnum, demo, canal, gain_conversion, offset_conversion, gain_direction, bias_direction, bias_motor);
    disp('POSICIÓN INICIAL ALCANZADA. PREPARADO PARA APLICAR EL ESCALÓN.');
    pause(2); % PAUSA PARA ASEGURAR QUE TODO ESTÁ ESTABLE

    % --- PREPARACIÓN PARA LA CAPTURA DE DATOS ---
    fig_realtime = figure('Name','CAPTURANDO RESPUESTA AL ESCALÓN...','NumberTitle','off');
    ax_realtime = axes;
    h_plot_realtime = plot(ax_realtime, NaN, NaN, 'b-', 'LineWidth', 2);
    title(ax_realtime, 'RESPUESTA EN TIEMPO REAL');
    xlabel(ax_realtime, 'TIEMPO [S]');
    ylabel(ax_realtime, 'POSICIÓN [CM]');
    grid(ax_realtime, 'on');
    
    num_pasos = floor(tiempo_experimento / dt);
    hist_tiempo = zeros(1, num_pasos);
    hist_posicion = zeros(1, num_pasos);
    
    % --- APLICAR EL ESCALÓN DE VOLTAJE Y COMENZAR EL BUCLE DE CAPTURA ---
    disp(['APLICANDO ESCALÓN DE ' num2str(voltaje_escalon) 'V...']);
    [~,idnum] = EDigitalOut(idnum,demo,1,0,gain_direction*voltaje_escalon+bias_direction);
    [errorCode, idnum] = EAnalogOut(idnum, demo, abs(voltaje_escalon),0.0);
    if errorCode ~= 0, error('ERROR EN EANALOGOUT: %d', errorCode); end
    [~,idnum] = EDigitalOut(idnum,demo,canal,1,bias_motor+abs(voltaje_escalon));
    
    tic; % INICIAR CRONÓMETRO
    for k = 1:num_pasos
        t_inicio_iteracion = toc;
        
        % LEER LA POSICIÓN ACTUAL
        [voltaje_sensor, ~, ~, ~] = EAnalogIn(idnum, demo, canal, 0);
        posicion_actual_cm = gain_conversion * voltaje_sensor + offset_conversion;
        posicion_actual_cm = max(0, min(pos_max_cm, posicion_actual_cm));
        
        % GUARDAR DATOS
        hist_tiempo(k) = toc;
        hist_posicion(k) = posicion_actual_cm;
        
        % ACTUALIZAR GRÁFICA EN TIEMPO REAL (DE FORMA EFICIENTE)
        set(h_plot_realtime, 'XData', hist_tiempo(1:k), 'YData', hist_posicion(1:k));
        drawnow limitrate;
        
        pause(max(0, dt - (toc - t_inicio_iteracion)));
    end
    
    disp('CAPTURA DE DATOS FINALIZADA.');

catch e
    fprintf('\n¡ERROR O DETENCIÓN MANUAL DURANTE EL EXPERIMENTO!\n');
    % --- APAGADO DE EMERGENCIA ---
    disp('APAGANDO EL MOTOR POR SEGURIDAD...');
    try
        [~, ~] = EAnalogOut(idnum, demo, 0.0, 0.0);
    catch
        disp('FALLO AL APAGAR EL MOTOR EN EL BLOQUE CATCH.');
    end
    rethrow(e);
end

%% PASO 3: APAGADO SEGURO
disp('APAGANDO EL MOTOR...');
try
    [~, ~] = EAnalogOut(idnum, demo, 0.0, 0.0);
    disp('MOTOR DETENIDO DE FORMA SEGURA.');
catch
    disp('ERROR DURANTE EL APAGADO SEGURO.');
end

%% PASO 4: ANÁLISIS AUTOMÁTICO DE PARÁMETROS (MÉTODO DE LA TANGENTE)
% SE USA LA MISMA LÓGICA DE ANÁLISIS, PERO CON UN PRE-PROCESAMIENTO DE DATOS PARA
% ELIMINAR PUNTOS DUPLICADOS Y EVITAR ERRORES EN LA INTERPOLACIÓN.

figure('Name','ANÁLISIS DE LA RESPUESTA EXPERIMENTAL','NumberTitle','off');
plot(hist_tiempo, hist_posicion, 'b', 'LineWidth', 2); grid on; hold on;
xlabel('TIEMPO [S]');
ylabel('SALIDA [CM]');
title('ANÁLISIS DE LA RESPUESTA AL ESCALÓN EXPERIMENTAL');

% --- PRE-PROCESAMIENTO DE DATOS PARA ASEGURAR PUNTOS ÚNICOS Y MONÓTONOS ---
% EL COMANDO 'UNIQUE' ELIMINA LOS PUNTOS DE POSICIÓN REPETIDOS Y NOS DA
% LOS ÍNDICES 'IA' DE LA PRIMERA VEZ QUE APARECEN.
[unique_pos, ia] = unique(hist_posicion);
% USAMOS ESOS MISMOS ÍNDICES PARA CREAR UN VECTOR DE TIEMPO CORRESPONDIENTE.
unique_time = hist_tiempo(ia);

% --- VERIFICACIÓN DE QUE EL SISTEMA SE HA MOVIDO LO SUFICIENTE ---
y_final = unique_pos(end);
y_inicial = unique_pos(1);
delta_y = y_final - y_inicial;

if delta_y < 0.1 % SI EL MOVIMIENTO ES INSIGNIFICANTE, NO SE PUEDE ANALIZAR
    warning('EL MOVIMIENTO DETECTADO ES DEMASIADO PEQUEÑO PARA REALIZAR UN ANÁLISIS FIABLE.');
    % SE SALTAN LOS CÁLCULOS SI NO HAY MOVIMIENTO
    Te_est = NaN; 
    T_est = NaN;
    K_est = NaN;
else
    % SE REALIZAN LOS CALCULOS SOBRE VALORES VALIDOS
    y_28 = y_inicial + 0.283 * delta_y;
    y_63 = y_inicial + 0.632 * delta_y;

    % INTERPOLAR PARA ENCONTRAR LOS TIEMPOS CORRESPONDIENTES
    % ESTE INTERP1 AHORA FUNCIONARÁ SIN ERROR.
    t_28 = interp1(unique_pos, unique_time, y_28);
    t_63 = interp1(unique_pos, unique_time, y_63);

    %  SE CALCULA LOS  PARÁMETROS DEL MODELO FOPDT (FIRST ORDER PLUS DEAD TIME)
    T_est = 1.5 * (t_63 - t_28);   % CONSTANTE DE TIEMPO ESTIMADA
    Te_est = t_63 - T_est;       % TIEMPO MUERTO ESTIMADO
    K_est = delta_y / voltaje_escalon; % GANANCIA ESTÁTICA ESTIMADA

    % GRAFICAR PUNTOS DE CÁLCULO
    plot(t_28, y_28, 'ro', 'MarkerFaceColor', 'r');
    plot(t_63, y_63, 'go', 'MarkerFaceColor', 'g');

    % DIBUJAR LÍNEA TANGENTE APROXIMADA
    if ~isnan(Te_est) && ~isnan(T_est) && T_est > 0
        t_tangente = linspace(Te_est, Te_est + T_est * 2, 100);
        y_tangente = y_inicial + (delta_y / T_est) * (t_tangente - Te_est);
        plot(t_tangente, y_tangente, '--m', 'LineWidth', 1.5, 'DisplayName', 'TANGENTE ESTIMADA');
    end
end

%% PASO 5: MOSTRAR RESULTADOS
fprintf('\n--- PARÁMETROS ESTIMADOS DE LA PLANTA (MÉTODO DE SMITH) ---\n');
if isnan(T_est)
    fprintf('NO SE PUDIERON ESTIMAR LOS PARÁMETROS.\n');
else
    fprintf('GANANCIA ESTÁTICA ESTIMADA (K):   %.3f (CM/V)\n', K_est);
    fprintf('TIEMPO MUERTO ESTIMADO (TE):      %.3f S\n', Te_est);
    fprintf('CONSTANTE DE TIEMPO ESTIMADA (T): %.3f S\n', T_est);
end
fprintf('----------------------------------------------------------\n');

legend('RESPUESTA EXPERIMENTAL','PUNTO AL 28.3%','PUNTO AL 63.2%','TANGENTE ESTIMADA');

%% FUNCIÓN AUXILIAR PARA POSICIONAMIENTO INICIAL
function mover_posicion(posicion_objetivo_cm, idnum, demo, canal, gain_conv, offset_conv, gain_dir, bias_dir, bias_mot)
    Kp_retorno = 0.8; 
    tolerancia_cm = 0.1;
    timeout_s = 20;
    
    tic;
    while toc < timeout_s
        [voltaje_sensor, ~, ~, ~] = EAnalogIn(idnum, demo, canal, 0);
        posicion_actual_cm = gain_conv * voltaje_sensor + offset_conv;
        
        error_retorno = posicion_objetivo_cm - posicion_actual_cm;
        
        if abs(error_retorno) < tolerancia_cm
            break; % POSICIÓN ALCANZADA
        end
        
        voltaje_salida = Kp_retorno * error_retorno;
        voltaje_salida = max(-5, min(5, voltaje_salida));
        
        [~,idnum] = EDigitalOut(idnum,demo,1,0,gain_dir*voltaje_salida+bias_dir);
        [~,idnum] = EAnalogOut(idnum, demo, abs(voltaje_salida),0.0);
        [~,idnum] = EDigitalOut(idnum,demo,canal,1,bias_mot+abs(voltaje_salida));
        
        pause(0.05);
    end
    [~, ~] = EAnalogOut(idnum, demo, 0.0, 0.0); % DETENER MOTOR AL FINAL
end