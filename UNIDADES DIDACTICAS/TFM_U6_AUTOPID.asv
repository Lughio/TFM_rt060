% ========================================================================
%  UNIDAD 6: CONTROL PID ADAPTATIVO CON AUTO-SINTONIZACIÓN (RLS)
%  Este script implementa un control adaptativo directo:
%  1. RLS estima el modelo de la planta en tiempo real.
%  2. El modelo se usa para recalcular los parámetros del PID periódicamente.
% =========================================================================
clc;
clear;
close all;


%PARAMETROS CONFIGURACION RLS
Factor_olvido = 0.995;
NumB=[rand];
DenA=[rand rand];
Vector_Prls=[];
VectorXrls=[];
Vector_Correccion_Numerador=[1];
Vector_Error=[];
Vector_Error_Autoajuste=[];
pass=1;
t0=0.01;%PERIODO DE MUESTREO
q=0.05; %VALOR DE CALIDAD
valido_NumB = NumB;
% --- PARAMETROS DE CONFIGURACION----
idnum = -1;
demo = 0;
canal = 0;
gain_conversion = 7.36;
offset_conversion=0.22;
gain_direction = 0.2;
bias_direction = 1;
bias_motor = 0.9;
Valor_Control=0;
% --- Parámetros del Bucle ---
consigna_cm = 13.5;          % Consigna de posición
tiempo_total_exp = 500;      % Duración del experimento (necesita tiempo para converger)

% --- CÁLCULO DE PARÁMETROS PID INICIALES ---
%[Kp, Ti, Td] = TFM_U6_calculate_pid_gains_chr(K_inicial, T_inicial, Tt_inicial);
%fprintf('Parámetros PID iniciales: Kp=%.2f, Ti=%.2f, Td=%.2f\n', Kp, Ti, Td);

% --- Inicialización de Variables de Estado ---
integral_error = 0;
posicion_anterior_cm = 0;
u_saturado_anterior = 0;

% LLAMAMIENTO A LA FUNCION DE GRAFICACION EN TIEMPO REAL
[~, ax] = ajuste_real_Plot();

%% BUCLE DE CONTROL ADAPTATIVO

try
      t_ref=tic; %inicio del contador
     while true
        dt = toc(t_ref);
        t_ref=tic;
    
        %SE LEE EL VOLTAJE
        [voltaje_actual, ~, errorCode, ~] = EAnalogIn(idnum, demo, canal, 0);
        if errorCode ~= 0, break; end
        %SE HACE LA CONVERSIÓN
        posicion_actual_cm = gain_conversion * voltaje_actual + offset_conversion;
        posicion_actual_cm = max(0, min(30.0, posicion_actual_cm));
        %SE HACE LA IDENTIFICACIÓN DEL SISTEMA DE LA PLANTA
        [NumB,DenA,Vector_Prls,VectorXrls]=TFM_U6_IRLS(Valor_Control,posicion_actual_cm,NumB,DenA,Vector_Prls,VectorXrls);
        Vector_Correccion_Numerador=[Vector_Correccion_Numerador(end) NumB];
        if isnan(NumB) || NumB <= 1e-6 % COMPROBACION DEL VALOR DEL NUMB
        NumB = valido_NumB; % 
        else
                valido_NumB = NumB; %GUARDA UN VALOR BUENO.
        end
        error_actual = consigna_cm - posicion_actual_cm;
        if length(Vector_Error)<1       %SEGUN LA ITERACCIÓN SE ELIGE EL ERROR
             Vector_Error_Autoajuste=[0,0,error_actual];%DURANTE LA PRIMERA ITERACCION LOS DOS ANTERIORES ERRORES SON CERO
        elseif length(Vector_Error)==1
               Vector_Error_Autoajuste=[0,Vector_Error(end),error_actual];%EN LA SEGUNDA ITERACCIÓN SOLO REQUERIMOS CONSERVAR UN CERO
        else
               Vector_Error_Autoajuste=[Vector_Error(end-1),Vector_Error(end),error_actual] ;% Y DESDE LA TERCERA, YA TENEMOS TODOS LOS VALORES DE ERROR
        end
        Vector_Error=[Vector_Error,error_actual];
        Kp= -(DenA(1)+2*DenA(end))*q/NumB(1);
        Td= (t0*DenA(end)*q)/(Kp*NumB(1));
        Ti=-t0/(1/(DenA(1)+2*DenA(end))+1+(Td/t0));  
        Kp = max(0.5, min(Kp, 20)); %HAY QUE LIMITAR EL KP A UN RANGO ACEPTABLE

        if Ti <= 0.01 % SE HACE UN CONTROL PARA EVITAR UN TI SUPER PEQUEÑO O NEGATIVO
            Ti = 0.01; %SE FUERZA PARA MANTENER UN VALOR POSITIVO Y ASI EVITAR INESTABILIDAD
        end
        Ti = min(Ti,0.8); %SE HACE UN CONTROL DE TI
        Td = max(0, min(Td, 10));%SE HACE UN CONTROL DE TD
        Valor_Control=Kp*(Vector_Error_Autoajuste(end)-Vector_Error_Autoajuste(2)+(t0/Ti)*Vector_Error_Autoajuste(end)+(Td/t0)*(Vector_Error_Autoajuste(end)-2*Vector_Error_Autoajuste(2)+Vector_Error_Autoajuste(1)))+Valor_Control;
        Valor_Control=max(-100,min(100,Valor_Control));    
        control_senal = ((Valor_Control -offset_conversion) / gain_conversion)/ 5.0;
        voltaje_salida_motor = control_senal * 5.00;
        control_senal=max(-100,min(100,control_senal)); 
        voltaje_salida_motor= max(-5, min(5, voltaje_salida_motor));
        [~,idnum] = EDigitalOut(idnum, demo, 1, 0, gain_direction * voltaje_salida_motor + bias_direction);
        [errorCode, idnum] = EAnalogOut(idnum, demo, abs(voltaje_salida_motor), 0.0);
        if errorCode ~= 0, error('Error en eDAC: %d', errorCode); end
        [~,idnum] = EDigitalOut(idnum, demo, canal, 1, bias_motor + abs(voltaje_salida_motor));
        pause(0.001);
        [errorCode, idnum] = EAnalogOut(idnum, demo, 0.0, 0.0);
        % --- Visualización en Tiempo Real ---
        actualizacion_Plot(ax, toc, posicion_actual_cm, consigna_cm, Valor_Control, Kp, Ti, Td);
        t0= (0.001);
        % --- Pausa para mantener el ciclo ---
        pause(0.001);
        
        if errorCode ~= 0, error('Error en eDAC: %d', errorCode); end
    end
catch e
    fprintf('¡DETENCIÓN DE EMERGENCIA O FIN DEL EXPERIMENTO!\n');
    rethrow(e);
end


%%  APAGADO SEGURO

disp('Apagando el motor...');
try
    [errorCode, ~] = EAnalogOut(idnum, demo, 0.0, 0.0);
    if errorCode ~= 0, error('Error en eDAC: %d', errorCode); end
catch
    disp('Error durante el apagado seguro.');
end

%%  FUNCIONES AUXILIARES LOCALES
function [fig, ax] = ajuste_real_Plot()
    fig = figure('Name', 'Control Adaptativo PID-RLS', 'NumberTitle', 'off');
    %GRAFICOS POSICION
    ax(1) = subplot(2,1,1);
    hold(ax(1), 'on');
    plot(ax(1), NaN, NaN, 'b-', 'LineWidth', 2, 'Tag', 'posicion');
    plot(ax(1), NaN, NaN, 'r--', 'Tag', 'consigna');
    grid(ax(1), 'on'); title(ax(1), 'Posición'); ylabel(ax(1), 'cm');
    legend(ax(1), 'Real', 'Consigna');
    % GRAFICOS CONTROL
    ax(2) = subplot(2,2,3);
    plot(ax(2), NaN, NaN, 'k-', 'Tag', 'control');
    grid(ax(2), 'on'); title(ax(2), 'Esfuerzo de Control'); ylabel(ax(2), 'u(t) [%]'); ylim(ax(2), [-110 110]);
    %GRAFICOS PID
    ax(3) = subplot(2,2,4);
    hold(ax(3), 'on');
    plot(ax(3), NaN, NaN, 'Tag', 'Kp');
    plot(ax(3), NaN, NaN, 'Tag', 'Ti');
    plot(ax(3), NaN, NaN, 'Tag', 'Td');
    grid(ax(3), 'on'); title(ax(3), 'Evolución Parámetros PID'); legend(ax(3), 'Kp', 'Ti', 'Td');
   
end

function actualizacion_Plot(ax, t, x, w, u, Kp, Ti, Td)
    % Posición
    hPos = findobj(ax(1), 'Tag', 'posicion');
    hCon = findobj(ax(1), 'Tag', 'consigna');
    set(hPos, 'XData', [get(hPos, 'XData') t], 'YData', [get(hPos, 'YData') x]);
    set(hCon, 'XData', [get(hCon, 'XData') t], 'YData', [get(hCon, 'YData') w]);
    % Control
    hCtrl = findobj(ax(2), 'Tag', 'control');
    set(hCtrl, 'XData', [get(hCtrl, 'XData') t], 'YData', [get(hCtrl, 'YData') u]);
    % PID
    hKp = findobj(ax(3), 'Tag', 'Kp');
    hTi = findobj(ax(3), 'Tag', 'Ti');
    hTd = findobj(ax(3), 'Tag', 'Td');
    set(hKp, 'XData', [get(hKp, 'XData') t], 'YData', [get(hKp, 'YData') Kp]);
    set(hTi, 'XData', [get(hTi, 'XData') t], 'YData', [get(hTi, 'YData') Ti]);
    set(hTd, 'XData', [get(hTd, 'XData') t], 'YData', [get(hTd, 'YData') Td]);
    drawnow limitrate;
end