clc;
clear;
close all;
% ========================================================================
%  UNIDAD 4: CONTROL PID SINTONIZACIÓN ESTÁNDAR
%  Este script implementa un control de un PID mediante Kp:
%  1. Mediante la prueba y error se establecen los valores del PID
%  2. Mediante el calculo de la Unidad 1 se puede establecer un valor de
%  conversión aproximado
%  3. El modelo grafica en tiempo real la posición de la maqueta y la potencia empleada.
% =============================================================================================================================

%%  PASO 1: CONFIGURACIÓN, CALIBRACIÓN E INICIALIZACIÓN

% ---PARAMETROS DE CONFIGURACION----
V_min_sensor =0;
V_max_sensor =5;
pos_max_cm = 30.0;
consigna_cm =28.5; 

%---PARAMETROS DE SINTONIZACIÓN DEL CHR-----
Kp = 11.8;
Ki = 0.04*Kp/1.0;
Kd = 0.20*Kp; 

%INICIALIZACION DE VARIABLES
integral_error = 0;
posicion_actual_cm=0;
voltaje_actual= 0.0;
sobrevoltaje=0;
error_ant=0;
gain_conversion=7.42;
error_conversion=0.13;
ajuste_v_motor=0.000;% esto me permite compensar pequeños errores
%al compensar esos errores puede mover el motor permitiendo precisar mas
%sin alterar los valores, debo tener cuidado para no caer en un sistema
%inestable
posicion_actual_cm=0.0;
gain_direction=0.2;
bias_direction=1;
bias_motor=0.9;
idnum = -1;
demo = 0;
canal = 0;
k=1;
%% ------------INTERFAZ GRÁFICA---------------
figureHandle = figure('Name', 'Respuesta del Sistema RT060 en Tiempo Real', 'NumberTitle', 'off');
%Cuadro de texto de consigna
uicontrol("Style","text",'Units','normalized',"Position",[0.01 0.97 0.3 0.03],'FontWeight','bold','String','INTRODUCE CONSIGNA:','Parent',figureHandle);
%Inicializacion de valor de consigna
variable_consigna=uicontrol('Style','edit','Units','normalized','Position',[0.30 0.97 0.20 0.04],'String',num2str(consigna_cm),'Parent',figureHandle);
%Boton de actualizacion de valor consigna
uicontrol('Style','pushbutton','Units','normalized','Position',[0.80 0.97 0.2 0.04],'FontWeight','bold','String','ACTUALIZAR','BackgroundColor',[0 1 0],'Callback',@(src,event) actualizarConsigna(variable_consigna,figureHandle),'Parent',figureHandle);
% Cuadro de visualización del valor consigna actual
uicontrol('Style','text','Units','normalized','Position',[0.55 0.97 0.20 0.03],'Tag','valorActual','FontWeight','bold','ForegroundColor',[1 0 0],'String',['VALOR ACTUAL: ',num2str(consigna_cm)],'Parent',figureHandle);
% Cuadro de visualización del valor posicion actual
uicontrol('Style','text','Units','normalized','Position',[0.57 0.932 0.10 0.03],'Tag','posActual','FontWeight','bold','ForegroundColor',[1 0 0],'String',[': '],'Parent',figureHandle);
% Cuadro de visualización del valor posicion actual
uicontrol('Style','text','Units','normalized','Position',[0.33 0.46 0.10 0.03],'Tag','conActual','FontWeight','bold','ForegroundColor',[1 0 0],'String',[': '],'Parent',figureHandle);
% Cuadro de visualización del valor posicion actual
uicontrol('Style','text','Units','normalized','Position',[0.78 0.46 0.10 0.03],'Tag','errActual','FontWeight','bold','ForegroundColor',[1 0 0],'String',[': '],'Parent',figureHandle);
% Graficacion de control
subplot(2,1,1); hPosicion = plot(NaN, NaN); hold on; hConsigna = plot(NaN, NaN, 'r--'); grid on; title('Posición'); ylabel('cm');
subplot(2,2,3); hControl = plot(NaN, NaN); grid on; title('Control'); ylabel('% Potencia');
subplot(2,2,4); hError= plot(NaN,NaN); grid on; title('Error'); ylabel('cm');
disp('Iniciando bucle de control...');
pause(1);

%% PASO 2: BUCLE DE CONTROL EN TIEMPO REAL
try
    t_graf=tic;
    t_ref=tic; %inicio del contador
    while ishandle(figureHandle)
        dt = toc(t_ref);
        t_ref=tic;
        variable_consigna_cm=str2double(get(variable_consigna,'String'));
        variable_consigna_cm = max(0.0, min(30.0, variable_consigna_cm));
        % SE LEE EL SENSOR Y  SE CONVERTE A UNIDADES 
        [voltaje_actual, sobrevoltaje, errorCode,idnum] = EAnalogIn(idnum, demo, canal,0);
        if errorCode ~= 0, disp(['Error en EAnalogIn: ' num2str(errorCode)]); break; end
        posicion_actual_cm = gain_conversion*voltaje_actual+error_conversion;
        posicion_actual_cm = max(0, min(pos_max_cm, posicion_actual_cm));
        if k == 1, posicion_anterior_cm = posicion_actual_cm; k=0; end % Inicialización

        % SE CALCULA EL ERROR 
        error_actual = (variable_consigna_cm - posicion_actual_cm);
       
        %----  SE CALCULAN LOS COEFICIENTES DEL PID ----
        
        % LA PARTE PROPORCIONAL
        P = Kp * error_actual;
        
        %LA PARTE INTEGRAL COMO SUMA DEL ERROR
        integral_error = integral_error + (error_actual * dt);
        I = Ki * integral_error;
        
       
        % LA PARTE DERIVADA 
        derivada_pos = (posicion_actual_cm - posicion_anterior_cm) / dt;
        D = - Kd * derivada_pos;
        
        % SE CALCULA LA SEÑAL DE CONTROL TOTAL  
        % LA SALIDA ES LA SUMA DE TODAS LAS PARTES
        y_total = (P + I + D);
       
        % SATURACIÓN Y ENVÍO AL MOTOR
        control_senal = ((y_total-error_conversion)/gain_conversion); %SE USA PARA DETERMINAR LA TENSION REQUERIDA
        voltaje_salida_motor= sign(control_senal)*ajuste_v_motor+control_senal;
        voltaje_salida_motor= max(-V_max_sensor, min(V_max_sensor, voltaje_salida_motor));
        control_senal=(voltaje_salida_motor/V_max_sensor)*100;
        % FUNCIONES PARA CONTROL DEL LABJACK
        [~,idnum]=EDigitalOut(idnum,demo,1,0,gain_direction*voltaje_salida_motor+bias_direction);
        [errorCode, idnum] = EAnalogOut(idnum, demo, abs(voltaje_salida_motor),0.0);
        if errorCode ~= 0, error('Error en eDAC: %d', errorCode); end
        [~,idnum]=EDigitalOut(idnum,demo,canal,1,bias_motor+abs(voltaje_salida_motor));

        % REGISTRO Y ACTUALIZACIÓN 
        posicion_anterior_cm = posicion_actual_cm; 
        
        % VISUALIZACIÓN EN TIEMPO REAL
        set(findobj(figureHandle,'Tag','posActual'),'String',[': ',num2str(posicion_actual_cm)]);
        set(findobj(figureHandle,'Tag','conActual'),'String',[': ',num2str(control_senal)]);
        set(findobj(figureHandle,'Tag','errActual'),'String',[': ',num2str(error_actual)]);
        set(hConsigna, 'XData', [get(hConsigna, 'XData') toc(t_graf)], 'YData', [get(hConsigna, 'YData') variable_consigna_cm]);
        set(hPosicion, 'XData', [get(hPosicion, 'XData') toc(t_graf)], 'YData', [get(hPosicion, 'YData') posicion_actual_cm]);
        set(hControl, 'XData', [get(hControl, 'XData') toc(t_graf)], 'YData', [get(hControl, 'YData') control_senal]);
        set(hError, 'XData', [get(hError, 'XData') toc(t_graf)], 'YData', [get(hError, 'YData') error_actual]);
        drawnow limitrate;
        pause(max(0, dt - toc(t_ref)));
    end
    
catch e
    disp('¡DETENCIÓN DE EMERGENCIA O FIN DEL EXPERIMENTO!');
    rethrow(e)
end

%%  PASO 3: APAGADO SEGURO Y VISUALIZACIÓN 
try
    [errorCode, ~] = EAnalogOut(idnum, demo,0.0,0.0);
    disp('APAGADO SEGURO REALIZADO')
    if errorCode ~= 0, error('Error en eDAC: %d', errorCode); end
catch
    disp('Error durante el apagado seguro.');
end

  %FUNCION DE ACTUALIZACION DE INTERFAZ GRAFICA
  function actualizarConsigna(variable_consigna,f)
        valor = str2double(get(variable_consigna,'String'));
        if isnan(valor)
            errordlg('Introduce un número válido','Error');
        else
            % Actualizar cuadro de visualización
            valorBox = findobj(f,'Tag','valorActual');
            valor = max(0.0, min(30.0, valor));
            set(variable_consigna,'String',num2str(valor));
            set(valorBox,'String',['VALOR ACTUAL: ',num2str(valor)]);
          
        end
    end
