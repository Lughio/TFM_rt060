clc;
clear;
close all;

% ========================================================================
%  UNIDAD 2: DETERMINA EL VALOR DE TENSION MINIMO PARA MOVER 0.01 CM
%  Este script implementan varios controladores para comprender la minima tensión requerida para mover:
%  1. Se inicia leyendo la tensión actual
%  2. Se realiza aumentos de tensión hasta ver un movimiento fisico en la
%  maqueta
%  3. Se detiene y muestra los valores
% ========================================================================

%% PASO 1: INICIALIZACION DE VARIABLES

% --- CARGA DE LIBRERIA---
%ESTE DRIVER EMPLEADO REQUIERE UNA INSTALACIÓN PREVIA
%SE EMPLEA ESTE DRIVER SOBRE OTROS CON MAS OPCIONES POR LA COMPATIBILIDAD CON SOFTWARE DE 64BITS%
%OTROS DRIVERS TIENEN PROBLEMAS CON EL SOFTWARE DE 64 BITS

%---PARAMETROS INICIALES DE LA PRUEBA---
voltaje_max_prueba = 5.0; % VOLTAJE_MAX_DEL SENSOR TEORICO.
incremento_voltaje = 0.01; % AUMENTO DEL VOLTAJE POR CICLO DEL BUCLE
tiempo_espera_paso = 0.1;  % TIEMPO DE ESTABILIZACIÓN
umbral_movimiento_cm = 0.02; % VALOR DE DESPLAZAMIENTO Á DETECTAR

%---PARAMETROS DE CONEXIONADO DEL LABJACK U12 RT060---
idnum = -1;
demo = 0;
canal_lectura = 0;
canal_escritura= 0; % Asumo que es el mismo canal que usas en EAnalogOut
gain_conversion = 7.36; %VALOR DE CONVERSION CALCULADA
offset_conversion=0.22;% VALOR DE OFFSET
%INICIALIZACIÓN DE VARIABLES
voltaje_arranque = -1; %VALOR DE INICIO O QUE NO SE ENCUENTRA EL ARRANQUE
voltaje_actual_motor = 0.0; %VOLTAJE AL QUE SE MUEVE EL MOTOR
posicion_inicial_cm = 0.0;

%% -----------------INTERFAZ GRAFICA-----------------------
%% ------------INTERFAZ GRÁFICA---------------
fig = figure('Name', 'DETECTOR DE VOLTAJE RT060', 'KeyPressFcn', 'uiresume(gcbf)');
ax = axes('Position', [0.05 0.5 0.9 0.2]);
titleHandle = title(ax, '...ESPERANDO DETECCIÓN...');
textHandle = text(0.5, 0.5, 'Desplazamiento: -- cm | V Requerido: -- V', 'FontSize', 18, ...
    'HorizontalAlignment', 'center', 'Parent', ax);
set(ax, 'XTick', [], 'YTick', []);
%CUADRO DE TEXTO VALOR GAIN_CONVERSION
uicontrol("Style","text",'Units','normalized',"Position",[0.01 0.95 0.3 0.03],'FontWeight','bold','String','GAIN_CONVERSION: ','Parent',fig);
%INICIALIZACION VALOR GAIN_CONVERSION
variable_gain=uicontrol('Style','edit','Units','normalized','Position',[0.30 0.95 0.20 0.04],'String',num2str(gain_conversion),'Parent',fig);
%CUADRO DE TEXTO VALOR OFFSET_CONVERSION
uicontrol("Style","text",'Units','normalized',"Position",[0.01 0.90 0.3 0.03],'FontWeight','bold','String','OFFSET_CONVERSION: ','Parent',fig);
%INICIALIZACION VALOR OFFSET_CONVERSION
variable_offset=uicontrol('Style','edit','Units','normalized','Position',[0.30 0.90 0.20 0.04],'String',num2str(offset_conversion),'Parent',fig);
%CUADRO DE TEXTO VALOR UMBRAL
uicontrol("Style","text",'Units','normalized',"Position",[0.01 0.85 0.3 0.03],'FontWeight','bold','String','UMBRAL MOVIMIENTO: ','Parent',fig);
%INICIALIZACION VALOR UMBRAL
variable_umbral=uicontrol('Style','edit','Units','normalized','Position',[0.30 0.85 0.20 0.04],'String',num2str(umbral_movimiento_cm),'Parent',fig);
%BOTON ACTUALIZACION
total_variable=[variable_gain variable_offset variable_umbral]
uicontrol('Style','pushbutton','Units','normalized','Position',[0.80 0.85 0.2 0.04],'FontWeight','bold','String','ACTUALIZAR','BackgroundColor',[0 1 0],'Callback',@(src,event) actualizarValores(total_variable,fig),'Parent',fig);

disp('Iniciando prueba de fricción estática...');
disp('El voltaje aumentará lentamente hasta que se detecte movimiento.');
pause(2);


%%  PASO 2: BUCLE DE PRUEBA EN LAZO ABIERTO

try
    %SE CALCULA LA POSICION INICIAL
    [voltaje_inicial_sensor, ~, ~, ~] = EAnalogIn(idnum, demo, canal_lectura, 0);
    posicion_inicial_cm = gain_conversion * voltaje_inicial_sensor+offset_conversion;
    fprintf('Posición inicial detectada: %.2f cm\n', posicion_inicial_cm);
    
    % BUCLE CON VOLTAJE INCREMENTAL
    for v_out = 0:incremento_voltaje:voltaje_max_prueba
        
        voltaje_actual_motor = v_out;
        
        % [errorcode, localID] = EDigitalOut(localID, demo, channel, writeD, state)
        [~,idnum]=EDigitalOut(idnum,demo,1,canal_escritura,0.2*voltaje_actual_motor+1);
        % [errorcode idnum] = EAnlaogOut(idnum, demo, analogOut0, analogOut1)
        [errorCode, idnum] = EAnalogOut(idnum, demo, voltaje_actual_motor, 0.0);
        if errorCode ~= 0, error('Error en EAnalogOut: %d', errorCode); end
        % [errorcode, localID] = EDigitalOut(localID, demo, channel, writeD, state)
        [~,idnum]=EDigitalOut(idnum,demo,0,1,0.9+abs(voltaje_actual_motor));
        
        %ACTUALIZACION DE INTERFAZ A MOVIMIENTO
        set(titleHandle, 'String', 'SUBIENDO VOLTAJE...');
        fprintf('Enviando voltaje: %.3f V... ', voltaje_actual_motor);
        % ESPERA A QUE SE ESTABILICE LA POSICION
        pause(tiempo_espera_paso);
        % DETENER MOTOR PARA ASEGURAR POSICION
        [errorCode, ~] = EAnalogOut(idnum, demo, 0.0, 0.0);
        % Esperar a que el sistema se estabilice
        pause(tiempo_espera_paso);
        % SE LEÉ POSICIÓN
        [voltaje_sensor_actual, ~, ~, ~] = EAnalogIn(idnum, demo, canal_lectura, 0);
        posicion_actual_cm = gain_conversion * voltaje_sensor_actual+offset_conversion;

        % ACTUALIZO CONSTANTEMENTE EL TEXTO PARA MOSTRAR LOS VALORES
        set(textHandle, 'String', sprintf('Desplazamiento: %.3f cm | V Requerido: %.3f V', (posicion_actual_cm - posicion_inicial_cm), voltaje_actual_motor));
        fprintf('Posición actual: %.2f cm\n', posicion_actual_cm);
        
        % SE COMPRUEBA SI SE SUPERA EL UMBRAL A DETECTAR
        if (posicion_actual_cm - posicion_inicial_cm) > umbral_movimiento_cm
            voltaje_arranque = voltaje_actual_motor;
            fprintf('\n--- ¡MOVIMIENTO DETECTADO! ---\n');
            fprintf('El umbral de fricción estática es aproximadamente: %.3f V\n', voltaje_arranque);
            break; % ACCIÓN PARA SALIR DEL BUCLE

        end
        %ACTUALIZACION DE INTERFAZ A MOVIMIENTO
        set(titleHandle, 'String', 'REINTENTANDO..');
        if posicion_inicial_cm<posicion_actual_cm
            posicion_inicial_cm=posicion_actual_cm;
        end
    end
    
    if posicion_inicial_cm == posicion_actual_cm
        fprintf('\n PRUEBA FINALIZADA SIN MOVIMIENTO DETECTADO HASTA %.2f V.\n', voltaje_max_prueba);
        fprintf('ADVERTENCIA:REQUIERE SUBIR EL VOLTAJE MAXIMO.\n');
    end

catch e
    disp('¡ERROR O DETENCIÓN MANUAL DURANTE LA PRUEBA!');
    rethrow(e)
end


%%  PASO 3: APAGADO SEGURO

disp('APGANDO MOTOR');
try
    % Poner el voltaje del motor a 0 para asegurar que se detiene
    [errorCode, ~] = EAnalogOut(idnum, demo, 0.0, 0.0);
    if errorCode ~= 0, error('ERROR EN EANALOGOUT: %d', errorCode); end
    disp('MAQUETA DETENIDA.');
catch ex
    disp('ERROR DE APAGADO.');
    disp(ex.message);
end

  %FUNCION DE ACTUALIZACION DE INTERFAZ GRAFICA
  function actualizarValores(total_variable,f)
   valores = zeros(1,length(total_variable));
    for i=1:length(total_variable)
         valor = str2double(get(total_variable(i),'String'));
         if isnan(valor)
             errordlg('Introduce un número válido','Error');
             return;
         else
             if i==1
                 valor=max(0.5,min(50,valor));
             elseif i==2
                 valor=max(0.0,min(1.0,valor));
             else
                 valor=max(0,min(0.5,valor));
             end
             set(total_variable(i),'String',num2str(valor));
             valores(i)=valor;
         end
    end
    end
